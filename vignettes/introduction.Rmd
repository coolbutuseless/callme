---
title: "Introduction"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---



```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
knitr::knit_engines$set(callme = callme::callme_engine)
library(callme)
```

```{css, echo=FALSE}
.callme         { background-color: #E3F2FD; }
pre.callme span { background-color: #E3F2FD; }
```


# Introduction

`{callme}` is a package for easily compiling inline C code for use within R.

Complied C code can be used to improve the speed of critical sections of code e.g.
tight loops of numeric operations.

In this introductory vignette, some common elements are described for C code
which operates with R objects

## Code Layout in Vignettes

The C code chunks in these vignettes is streamlined for display purposes.

In general when using `{callme}` you must:

1. Define the C code 
    * in a string (usually called `code` in examples in this package)
    * in a `.c` file
2. Call `callme::compile(code)` or `callme::compile("file.c")`

This standard way of compiling the code in R is shown below:

```{r eval=FALSE}
code <- r"(
SEXP print_with_c(SEXP string) {
   Rprintf("Printing in C: '%s'\n", CHAR(asChar(string)));
   return R_NilValue;
}
)"

callme::compile(code, invisible = TRUE)
print_with_c("hello")
```

In order to focus on the actual C code (with C code syntax highlighting), 
C code will simply be shown in a blue box.   Assigning the code to a string, 
and calling `callme::compile(code)` is performed, but not shown in the vignettes.

```{callme}
#| invisible=TRUE
SEXP print_with_c(SEXP string) {
   Rprintf("Printing in C: '%s'\n", CHAR(asChar(string)));
   return R_NilValue;
}
```

```{r}
print_with_c("hello")
```




## Example: Add two vectors of floating point numbers

The following code adds two vectors of floating point values and returns
the result (i.e. `a + b`).


```{callme}
SEXP add(SEXP a, SEXP b) {
  
  // Sanity checks
  if (length(a) != length(b)) {
    error("'a' and 'b' must be the same length");
  }
  
  // Get a pointer to the actual numeric data in 'a' and 'b'
  double *ap = REAL(a);
  double *bp = REAL(b);
  
  // Allocate a new R object 'res' and protect it from garbage collection
  int N = length(a);
  SEXP res = PROTECT(allocVector(REALSXP, N));
  
  // Get a pointer to the actual numeric data in 'res'
  double *resp = REAL(res);
  
  // Add elements of two arrays in C
  for (int i = 0; i < N; i++) {
    resp[i] = ap[i] + bp[i];
  }
  
  // Unwind any protection and return the R result
  UNPROTECT(1);
  return res;
}
```


```{r}
add(c(1, 2, 3), c(4, 5, 6))
```


## Elements to note in the example

The following elements highlighted here are described in more detail in 
other vignettes within this package.

###  Function signature

Function signatures must be of the format `SEXP funcname(SEXP arg1, SEXP arg2, ... SEXP argn)`


### Sanity checking

There is a much greater need for checking for sane arguments in C compared to 
R.   In R, an out-of-bounds memory access might only result in an `NA` value, but
in C such a memory access can cause memory corruption and crashes.

In the example above, the lengths of the two input vectors were checked as
automatic vector recyling does not happen in C like it does in R.


### Unpack R objects into C equivalents

All R objects are of type `SEXP` and are a combination of metadata and
the actual dta useful to C.

The C compatible data must be extraced from the `SEXP` e.g. find the pointer
to the array of doubles using:

```{callme}
#| compile = FALSE, headers = FALSE, rcode = FALSE
double *ap = REAL(a);
```

### Allocte new R objects within C

New R objects can be created within C using `allocVector()` and related functions.

It is important to `PROTECT()` any R objects created within C - otherwise
R's garbage collection will consider them unused and try to free the memory 
in which they store data.


### Return object from C to R

The final returned object must also be of type `SEXP`.  This object may
have been created with a call to `allocVector()` but there are convenience
functions for creating and returning single values e.g. `ScalarInteger()`







#### Sanity checking

The `SEXP` type can contain any R object, so when passed in to a C function from 
R, it is necessary to confirm that it is sane i.e.

* Is it the right type of data?
* Is it the right length?
* Do all objects together make sense? e.g. must they all be the same length?

Some checks will need to be explicit.  In the example, the `a` and `b` arguments
are checked if they are the same length and an error is raised if not.  (`error()` is
the C equivalenth of R's `stop()`)

```{callme}
#| compile=FALSE, headers=FALSE, rcode=FALSE
// Sanity checks
if (length(a) != length(b)) {
  error("'a' and 'b' must be the same length");
}
```

If this check was skipped, then later in the example the expression `a[i] * b[i]`
is possibly going to try and access memory that is out-of-bounds!


There are some checks which are implicit in that R will complain if you try 
to use a value in an inappropriate way.  For example, if a character vector
is passed in as an argument to `add()`, the `REAL()` macro will try to 
extract numeric data from the string and fail:

```{r error = TRUE}
add(1.0, 2.0)     # Good: both types are floating point numeric values
add(1.0, "hello") # Bad : Can't treat "hello" as a number 
```









#### Allocate a new R object to use as the result

Standard R types may be created with a call to `allocVector()`.

Because we are operating within C, and the object is not assigned to an R 
variable, it is necessary to tell R that we are using the object.  This 
is done with a `PROTECT()` call, and stops R's garbage collector from trying to free the memory.

In general, every R object created within C should be wrapped in a `PROTECT()`.

When we leave the function, tally the calls to `PROTECT()` and undo them with
`UNPROTECT(n)`.  



```{callme}
SEXP alloc_integer(SEXP n) {
  int len = INTEGER(n)[0];
  SEXP res = PROTECT(allocVector(INTSXP, len));
  int *resp = INTEGER(res);
  for (int i = 0; i < len; i++) {
     resp[i] = i;
  }
  UNPROTECT(1);
  return res;
}
```


```{r}
alloc_integer(10L)
```



#### Standard C code

In the middle of this C code there's often identifiable bit of just plain C code - usually the entire purpose of calling C from R

In the above example this core C code is just looping over two C arrays
of doubles and summing the result.

```{callme}
#| compile=FALSE, headers=FALSE, rcode=FALSE
for (int i = 0; i < N; i++) {
  resp[i] = ap[i] + bp[i];
}
```


#### Tidy and return

* `UNPROTECT()` any objects you `PROTECT()`ed
* Return an `SEXP` object.
* Any other `SEXP` objects allocated within the function but not returned will
  be garbage collected later by R.


## Printing values in C

In general:

* Use `Rprintf()` instead of `printf()`.  It is analogous to `cat(sprintf(...))` in R
* `warning()` in C is analogous to `warnings(sprintf(...))` in R
* `error()` in C is analogous to `stop(sprintf(...))` in R

```{callme}
SEXP print_some_things(void) {
  Rprintf("Rprintf()\n");
  warning("warning()\n");
  error("error");
  return R_NilValue;
}
```


```{r error = TRUE}
print_some_things()
```




