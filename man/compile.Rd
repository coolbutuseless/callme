% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compile.R
\name{compile}
\alias{compile}
\title{Compile C code and load into R for use with \code{.Call()}}
\usage{
compile(
  code,
  PKG_CPPFLAGS = NULL,
  PKG_LDFLAGS = NULL,
  env = parent.frame(),
  overwrite = "callme",
  verbosity = 0
)
}
\arguments{
\item{code}{C code following the \code{.Call()} conventions.  Must
also include any \code{#include} statements.}

\item{PKG_CPPFLAGS}{character string of flags for the C pre-processor.
Default: NULL
e.g. \code{PKG_CPPFLAGS = "-I/opt/homebrew/include"} to add the include path 
for homebrew to the compilation step.}

\item{PKG_LDFLAGS}{character string of flags when linking. Default: NULL.
e.g. \code{PKG_LDFLAGS = "-L/opt/homebrew/lib -lzstd"} to include the homebrew 
libraries in the linker search path and to link to the \code{zstd}
library installed there.}

\item{env}{environment into which to assign the R wrapper functions.
Default: \code{parent.frame()}.  If \code{NULL} then no 
assignment takes place.}

\item{overwrite}{which existing variables can be overwritten when this function
       creates wrapper variables? If permission not given to overwrite a 
       variable which already exists in the environment, then an error is 
       raised.
\describe{
\item{"callme"}{(Default) Only overwrite other functions created by this package}
\item{"all"}{All variables will be overwritten}
\item{"functions"}{Only functions are overwritten}
\item{"none"}{No variables may be overwritten}
}}

\item{verbosity}{Level of output: Default: 0. current max: 2}
}
\value{
Invisibly returns a named list of R functions. Each R function 
        calls to the equivalent C functions.
}
\description{
See also \code{?SHLIB}
}
\examples{
code <- "
#include <R.h>
#include <Rdefines.h>

// Add 2 numbers
SEXP add(SEXP val1, SEXP val2) {
  return ScalarReal(asReal(val1) + asReal(val2));
}

// Multiply 2 numbers
SEXP mul(SEXP val1, SEXP val2) {
  return ScalarReal(asReal(val1) * asReal(val2));
}

// sqrt elements in a vector
SEXP new_sqrt(SEXP vec) {
  SEXP res = PROTECT(allocVector(REALSXP, length(vec)));
  double *res_ptr = REAL(res);
  double *vec_ptr = REAL(vec);
  for (int i = 0; i < length(vec); i++) {
    res_ptr[i] = sqrt(vec_ptr[i]);
  }
  
  UNPROTECT(1);
  return res;
}
"

# compile the code and load into R
compile(code)

# Call the functions
add(99.5, 0.5)
mul(99.5, 0.5)
new_sqrt(c(1, 10, 100, 1000))
}
