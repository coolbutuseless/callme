% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/callme.R
\name{callme}
\alias{callme}
\title{Compile C code and load into R for use with \code{.Call()}}
\usage{
callme(code, cpp_flags = NULL, ld_flags = NULL)
}
\arguments{
\item{code}{C code following the \code{.Call()} conventions.  Must
also includes any \code{#include} statements.}

\item{cpp_flags}{character string of flags for the C pre-processor.
Default: NULL
e.g. \code{"-I/opt/homebrew/include"} to add the include path 
for homebrew to the compilation step.}

\item{ld_flags}{character string of flags when linking. Default: NULL.
e.g. \code{"-L/opt/homebrew/lib -lzstd"} to include the homebrew 
libraries in the linker search path and to link to the \code{zstd}
library installed there.}
}
\value{
A reference to the dynamic library which was loaded into R with 
        \code{dyn.load()} i.e. a 'DLLInfo' object.  This has been setup 
        such that when the returned object goes out of scope, the dynamic 
        library is unloaded i.e. the C function will no longer be accessible.
        Thus the user needs to keep a reference to this returned object for 
        as long as they need access to the C function.
}
\description{
See also \code{?SHLIB}
}
\examples{
\dontrun{
  code <- "
#include <R.h>
#include <Rdefines.h>
SEXP calc_(SEXP val1_, SEXP val2_) {
  return ScalarReal(asReal(val1_) + asReal(val2_));
}"

# Need to keep a reference to the returned value in order to retain access
# to the compiled functions.  I.e. the dll will be unloaded (via \code{dyn.unload()})
# when \code{'dll'} gets garbage collected.
dll <- callme(code)

# Call the function
.Call("calc_", 1, 2.5)

# Advanced: Get info about the C function / library.
dll$calc_
}


}
