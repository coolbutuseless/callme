% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/callme.R
\name{callme}
\alias{callme}
\title{Compile C code and load into R for use with \code{.Call()}}
\usage{
callme(code, cpp_flags = NULL, ld_flags = NULL, verbose = FALSE)
}
\arguments{
\item{code}{C code following the \code{.Call()} conventions.  Must
also include any \code{#include} statements.}

\item{cpp_flags}{character string of flags for the C pre-processor.
Default: NULL
e.g. \code{cpp_flags = "-I/opt/homebrew/include"} to add the include path 
for homebrew to the compilation step.}

\item{ld_flags}{character string of flags when linking. Default: NULL.
e.g. \code{ld_flags = "-L/opt/homebrew/lib -lzstd"} to include the homebrew 
libraries in the linker search path and to link to the \code{zstd}
library installed there.}

\item{verbose}{Should the output of the compiler be echoed to the R console?
Default: FALSE}
}
\value{
A named list of R functions which wrap the calls to the equivalent
        C functions.  When this returned object is garbage collected, the
        generated library will be unloaded.
}
\description{
See also \code{?SHLIB}
}
\examples{
\dontrun{
  code <- "
#include <R.h>
#include <Rdefines.h>
SEXP calc_(SEXP val1_, SEXP val2_) {
  return ScalarReal(asReal(val1_) + asReal(val2_));
}"

# Need to keep a reference to the returned value in order to retain access
# to the compiled functions.  I.e. the dll will be unloaded (via \code{dyn.unload()})
# when \code{'dll'} gets garbage collected.
dll <- callme(code)

# Manually call the function
.Call("calc_", 1, 2.5)

# Use the auto-generated wrapper function
dll$calc_(1, 2.5)
}


}
